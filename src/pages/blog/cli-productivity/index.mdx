---
layout: ../../../layouts/BlogLayout.astro
pubDate: 2024/04/26
title: "Spotlight: CLI Productivity"
description: "My command-line-centric workflow where I do my best work."
---

import BlogPicture from '../../../components/BlogPicture.astro';

# command line productivity

## intro

You can achieve peak productivity with nothing but the command line and
your web browser. I will describe my minimal, focused, keyboard-centric
workflow where I do my best work.

The goal of this article is not to convince you to make monumental changes in 
your developer workflow overnight, nor is it a hit-job against "mainstream"
editors and IDEs. My intention is to expose you to my perspective and the tools
which work for me. 

There are, in my mind, two distinct domains of technical productivity:

1. On one hand, you have tools like
[Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
and [Github](https://github.com/). They are essential overhauls to your
productivity. They save the day when things go awry, and should be used in
every single case. They will not be the focus of this article.

2. On the other hand, there are tools which genuinely increase the rate at
which you produce code and complete tasks. **This is what I am showcasing today.**

Let's go!

---

## shells

A command-line interface (CLI) is an operating system shell that uses
interactive keyboard inputs to commmunicate with the OS. You are probably
looking at one[^1] right now: `bash` ‚Äì the default
[UNIX](https://www.hpc.iastate.edu/guides/unix-introduction#:~:text=What%20is%20UNIX%3F,for%20servers%2C%20desktops%20and%20laptops.)
shell, or command prompt for Windows.

These shells "get the job done", but are barebones compared to better,
feature-rich alternatives.

### shell showdown!

`zsh` is the most widely used alternative shell. And rightfully so, for it
is rich with benefits. `zsh` is more customizable, the prompts are more 
versatile, and the completion speed is faster than `bash`. 

In addition, `bash` cannot handle floating-point arithmetic i.e. 
`number=$((3.1/4.7))` or arrays[^2]. Support for both while scripting gives `zsh`
the edge. It also has unicode support! üòä

`fish`, a strong contender for my new favorite shell, is another option. It
boasts a user-friendly syntax, making it somewhat easier to grasp than `zsh`
which emulates bash's more complex syntax. Unlike `zsh`, `fish` does away with
aliases (see [#customization](#customization)), relying solely on the superset
‚Äì functions. This simplifies shell interaction
at the cost of functionality some users might appreciate. 

In addition, `fish` excels with tab-completion generated from man-pages, a 
feature which is absent in `bash` or `zsh` by default[^3].

In the end, the choice of shell is a personal one. I recommend `zsh` for its flexibility and speed, but `fish` is a great choice for beginners or those who prefer a more user-friendly experience with
better out-of-the-box features.

### customization

`zsh` and `fish` are both highly customizable. `zsh` has a plugin system,
[oh-my-zsh](https://ohmyz.sh/), which is a collection of plugins and themes for
`zsh`. `fish` has a similar system,
[oh-my-fish](https://github.com/oh-my-fish/oh-my-fish). Both are great starting
points for customizing your shell.

Additionally, making use of aliases and functions can greatly improve your 
workflow. For example, I have an alias `alias g='git'` which allows me to type
`g` instead of `git`. This is a simple example, but you can create aliases for
more complex commands or functions to automate tasks.

The .zshrc file is a configuration file for `zsh`. It is located in your home
directory. The contents of this file are
[sourced](https://unix.stackexchange.com/questions/63765/what-does-sourcing-a-file-mean-in-a-shell)
every time the shell is started, allowing us to achieve persistent aliases and
customizations.

A similar file exists for `fish`, located at ~/.config/fish/config.fish. Here is a concise sample:

```bash
# colorful cat ·ìö·òè·ó¢
alias ccat 'pygmentize -g'

# shorthand
alias ut 'uptime'
alias so 'source'
alias l 'eza --group-directories-first' # my ls alternative
alias la 'l -a'
alias ll 'l --git -l'

alias vim 'nvim' # neovim btw

# quick edits
alias ea 'nvim ~/.config/fish/aliases.fish'
alias ev 'cd ~/.config/nvim/ && nvim .'
alias lc 'cd ~/dev/.leetcode && nvim .'

# you can craft functions too!
function timestamp
    python -c 'import time; print(int(time.time()))'
end

```

### installation & resources
* Fundamentals
    * Escape Windows hell with WSL: https://learn.microsoft.com/en-us/windows/wsl/install
    * If you are on Mac and aren't using Homebrew as a pkg manager... use it: https://brew.sh/
* Everything fish: https://fishshell.com/
    * OMF: https://github.com/oh-my-fish/oh-my-fish?tab=readme-ov-file#installation
* Everything zsh: https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH
    * OMZ: https://ohmyz.sh/

Fundamentally, your choice of shell is an essential building block atop which
the rest of your workflow is structured. Take some time to spice it up in ways
that make sense to you, and you won't regret it!

---

## tmux

A terminal multiplexer is a program that transparently "stands between" your
active terminal connection and <i>K</i> spawned terminal sessions. With `tmux` you
can start a session on a remote server, launch applications in that session,
then detach and reattach from that session at will.

<BlogPicture src="https://omniti.com/i/terminal_multiplexing_before_and_after-small.png" alt="Multiplexing Diagram" />
In other words, ``tmux`` allows you to do everything within a single terminal
application window. You can start
and jump between several terminal instaces with hotkeys, and divide each
instance into different panes. These terminal instances persist,
even when the application is closed, then reopened.

`tmux` is really cool and I recommend checking it out.

### customization
`tmux` looks for files at `~/.tmux.conf` or `~/.config/tmux.conf`. This is
where you can customize the multiplexer, add a plugin manager, and add plugins
and themes.

Let me walk you through my config:

```shell
# (1)  we set up a keybind to source the file (i.e. reload after changes):
unbind r
bind r source-file ~/.tmux.conf \; display-message "Config reloaded..."

# (2) we assign a <Leader> prefix key to <C-Space> or "Ctrl + Space"
#     this keystoke preceeds any tmux related keybindings.
set -g prefix C-Space
set -g status-position top

# (3) act like vim
setw -g mode-keys vi
bind-key h select-pane -L
bind-key j select-pane -D
bind-key k select-pane -U
bind-key l select-pane -R

# (4) make sure it utilizes the full range of colors
set -ga terminal-overrides ',*256color*:smcup@:rmcup@'

# (5) minimalism!
set -g visual-activity off
set -g visual-bell off
set -g visual-silence off
setw -g monitor-activity off
set -g bell-action none

# (6) plugin setup
set -g @plugin 'tmux-plugins/tpm' # load our plugin manager tpm first 
set -g @plugin 'tmux-plugins/tmux-sensible'
# set -g @plugin 'catppuccin/tmux'
set -g @plugin 'guedesfelipe/catppuccin_tmux#1.0.0' # our color scheme
set -g @plugin 'tmux-plugins/tmux-resurrect' # tmux sessions persist after restart

# (7) catppuccin color scheme customization
set -g @catppuccin_window_right_separator "‚ñà "
set -g @catppuccin_window_number_position "right"
set -g @catppuccin_window_middle_separator " | "

set -g @catppuccin_window_default_fill "none"

set -g @catppuccin_window_current_fill "all"

set -g @catppuccin_status_modules_right "application session date_time"
set -g @catppuccin_status_left_separator "‚ñà"
set -g @catppuccin_status_right_separator "‚ñà"

set -g @catppuccin_date_time_text "%Y-%m-%d %H:%M:%S"

# initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run '~/.tmux/plugins/tpm/tpm'
```

### installation & resources
* Everything tmux: https://tmuxcheatsheet.com/
* Catppuccin color scheme docs: https://github.com/catppuccin/tmux
    * Another great color pallete is rose-pine: https://github.com/rose-pine/tmux

Use `tmux`. It makes everything easier.

---

## Vim

I have been using Vim for about two years. When Vim is mentioned, it's usually
in one of two contexts: `vim` (the program) or Vim Motions. 

### Vim Motions
Everyone should use Vim Motions. They are extremely efficient. They are available
in all major editors. 

### Vim
Vim the program isn't as univeral. My blind dart board toss is that ~80% of developers use Microsoft
products like Visual Studio Code or JetBrains products like IntelliJ. These are 
extremely valuable out-of-the-box editors and IDEs. However, a smaller subset
prize modular customization and blazingly fast speed. These individuals usually
begin with Vim and migrate to expanded forks of this 

---

## .dotfiles

Creation of a Dotfiles directory brings everything together by making your
productivity workflow reproducible on any machine in just a few minutes.

Many programs store their configuration files in plain text files. These 
are usually (but not always) in your `~` or `~/.config/~` directories. Dotfiles
are configuration files for various programs. What sets them apart
from regular files and directories is their prefix: a dot (`.`). 

On Unix based systems, dotfiles are hidden by the OS by default. 

Some common dotfiles are: 
* `.bash_profile` and `.bashrc` for the Bash shell
* `.zshrc` for the Zsh shell
* `.vimrc` for Vim (or `~/.config/nvim/`) for Neovim
* `.tmux.conf` for Tmux
* `.gitignore` and `.gitconfig` global defaults in `~`

Gather up all of your configuration files and copy them into a Dotfiles
directory. Now, a copy of everything is in the same place. Put that
in a public[^4] GitHub repository. 

You can expand on this by rerouting your programs to look for their config files
within `~/.dotfiles` (or similar) instead of their defaults. You can
make liberal use of scripting to automate all of this. In theory one or two
scripts can get everything up and running.

If you're curious, you can access my .dotfiles 
[here](https://github.com/nicosalm/.dotfiles). It may not be up to date.


---

## wrapping up

---

[^1]: View any running shell process with `ps` or `echo $SHELL` to see your login (default) shell.

[^2]: While `bash` has "arrays", it doesn't implement true array data structures.
Under the hood [they are (index, value) linked lists](https://github.com/lucasscharenbroch/bash-with-floats/blob/master/array.c#L5). `zsh` implements true arrays capable of pointer arithmetic. With larger datasets, the difference in efficiency is notable.

[^3]: This feature can be added to `zsh` with the `zsh-autosuggestions` plugin.

[^4]: We opt for a public repository so you can clone it on any machine without
needing to verify your GitHub credentials first.
